# Risc-V学习


## 第一章 为什么要有 RISC-V

RISC-V的目标是成为一个通用的指令集架构（ISA）：

- 它要能适应包括从最袖珍的嵌入式控制器，到最快的高性能计算机等各种规模的处理器
- 它应该能兼容各种流行的软件栈和编程语言
- 它应该适应所有实现技术，包括现场可编程门阵列（FPGA）、 专用集成电路（ASIC）、 全定制芯片， 甚至未来的设备技术
- 它应该对所有微体系结构样式都有效：例如微编码或硬连线控制;顺序或乱序执行流水线; 单发射或超标量等等
- 它应该支持广泛的专业化，成为定制加速器的基础，因为随着摩尔定律的消退，加速器的重要性日益提高。
- 它应该是稳定的，基础的指令集架构不应该改变。

它是一个最近诞生的指令集架构，也是一个开源的指令集架构。

### 模块化与增量型 ISA

RISC-V的不同寻常之处，除了在于它是最近诞生的和开源的以外，还在于：和几乎所有以往的ISA不同，它是模块化的。

它的核心是一个名为RV32I的基础ISA，RV32I是固定的，永远不会改变。

模块化来源于可选的标准扩展，根据应用程序的需要，硬件可以包含或不包含这些扩展。

### ISA 设计 101

架构师在设计 ISA 时的基本原则和必须做出的权衡：

- 成本（美元硬币）
- 简洁性（轮子）
- 性能（速度计）
- 架构和具体实现的分离（分开的两个半圆）
- 提升空间（手风琴）
- 程序大小（相对的压迫着一条线的两个箭头）
- 易于编程/编译/链接（儿童积木“像 ABC 一样简单”）

## 第二章 RV32I： RISC-V 基础整数指令集

- 32 位字节可寻址的地址空间
- 所有指令均为 32 位长
- 31 个寄存器，全部 32 位宽，寄存器 0 硬连线为零
- 所有操作都在寄存器之间（没有寄存器到内存的操作）
- 加载/存储字加上有符号和无符号加载/存储字节和半字
- 所有算术，逻辑和移位指令都有立即数版本的指令
- 立即数总是符号扩展
- 仅提供一种数据寻址模式（寄存器+立即数）和 PC 相对分支
- 无乘法或除法指令
- 一个指令，用于将大立即数加载到寄存器的高位，这样加载 32 位常量到寄存器只需要两条指令

### 六种基本指令格式：

- 用于寄存器-寄存器操作的 R 类型指令
- 用于短立即数和访存 load 操作的 I 型指令
- 用于访存 store 操作的 S 型指令
- 用于条件跳转操作的 B 类型指令
- 用于长立即数的 U 型指令
- 用于无条件跳转的 J 型指令

### RV32I 寄存器：

- RV32I 有 31 寄存器加上一个值恒为 0 的 x0 寄存器

### RV32I 整数计算：

- 简单的算术指令（add, sub）、逻辑指令（and, or, xor），以及图 2.1 中的移位指令（sll, srl, sra） 和其他 ISA 差不多。
- RV32I 提供一个当小于时置位的指令
- RISC-V 中没有字节或半字宽度的整数计算操作
- RV32I 也不包含乘法和除法，它们包含在可选的 RV32M 扩展中

### RV32I 的 Load 和 Store

- RV32I 支持加载有符号和无符号字节和半字（lb， lbu， lh， lhu）和存储字节和半字（sb， sh）

### RV32I 条件分支  无条件跳转

- RV32I 可以比较两个寄存器并根据比较结果上进行分支跳转。
- 跳转并链接指令（jal）具有双重功能。

### RV32I 杂项

- 控制状态寄存器指令 (csrrc、 csrrs、 csrrw、 csrrci、 csrrsi、 csrrwi)，使我们可以轻松地访问一些程序性能计数器
-  ecall 指令用于向运行时环境发出请求，例如系统调用。
-  fence 指令对外部可见的访存请求，如设备 I / O 和内存访问等进行串行化。

## 第三章 RISC-V 汇编语言

- 汇编器向 RISC-V ISA 中增加了 60 条伪指令，使得 RISC-V 代码更易于读写，并且不增加硬件开销。
- 将一个寄存器硬编码为 0 使得其中许多伪指令更容易实现。
- 使用加载高位立即数（lui）和程序计数器与高位立即数相加（auipc）两条指令，简化了编译器和链接器寻找外部数据/函数的地址的过程。
- 使用相对地址转移的代码与位置无关，减少了链接器的工作。
- 大量的寄存器减少了寄存器保存和恢复的次数，加速函数调用和返回。
